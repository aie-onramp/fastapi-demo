# Data Model: Blackbird Customer Support Application

**Feature**: 001-blackbird-refactor
**Date**: 2025-11-17
**Phase**: 1 - Design & Contracts

## Overview

This document defines the data entities, relationships, and validation rules for the Blackbird application. The model preserves the existing HuggingFace dataset schema while adding conversation history tracking.

## Entity Relationship Diagram

```
┌─────────────────┐         ┌──────────────────┐
│    Customer     │1       *│      Order       │
│─────────────────│◄────────│──────────────────│
│ id (PK)         │         │ id (PK)          │
│ name            │         │ customer_id (FK) │
│ email (UNIQUE)  │         │ product          │
│ phone           │         │ quantity         │
│ username (UNIQUE│         │ price            │
└─────────────────┘         │ status           │
        │                   └──────────────────┘
        │
        │ 0..*
        │
        ▼
┌──────────────────────┐
│    Conversation      │
│──────────────────────│
│ id (PK)              │
│ customer_id (FK, NULL│
│ created_at           │
│ updated_at           │
└──────────────────────┘
        │
        │ 1..*
        │
        ▼
┌──────────────────────┐
│      Message         │
│──────────────────────│
│ id (PK)              │
│ conversation_id (FK) │
│ role                 │
│ content              │
│ tool_calls (JSON)    │
│ tool_results (JSON)  │
│ created_at           │
└──────────────────────┘
```

## Entities

### 1. Customer

**Purpose**: Represents an end-user customer account with contact information.

**Fields**:

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY | Unique customer identifier (7-digit string) |
| name | TEXT | NOT NULL | Customer full name |
| email | TEXT | NOT NULL, UNIQUE | Customer email address |
| phone | TEXT | NOT NULL | Customer phone number (format: XXX-XXX-XXXX) |
| username | TEXT | NOT NULL, UNIQUE | Customer username for account login |

**Validation Rules**:
- `email`: Must match email regex pattern: `^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`
- `phone`: Must match phone pattern: `^\d{3}-\d{3}-\d{4}$`
- `username`: 3-20 characters, alphanumeric + underscores only
- `name`: 1-100 characters, non-empty

**Relationships**:
- One customer can have many orders (1:N with Order)
- One customer can have many conversations (1:N with Conversation, optional)

**Indexes**:
```sql
CREATE INDEX idx_customers_email ON customers(email);
CREATE INDEX idx_customers_username ON customers(username);
```

---

### 2. Order

**Purpose**: Represents a product purchase transaction with status tracking.

**Fields**:

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY | Unique order identifier (5-digit string) |
| customer_id | TEXT | NOT NULL, FOREIGN KEY → customers(id) | Reference to owning customer |
| product | TEXT | NOT NULL | Product name/description |
| quantity | INTEGER | NOT NULL, CHECK (quantity > 0) | Number of units ordered |
| price | REAL | NOT NULL, CHECK (price >= 0) | Unit price in USD |
| status | TEXT | NOT NULL, CHECK (status IN (...)) | Order status (enum) |

**Validation Rules**:
- `quantity`: Must be positive integer (1-999)
- `price`: Must be non-negative decimal (0.00-9999.99)
- `status`: Must be one of: `"Processing"`, `"Shipped"`, `"Delivered"`, `"Cancelled"`
- `product`: 1-200 characters, non-empty

**Business Rules**:
- Orders can only be cancelled if `status = "Processing"`
- Status transitions:
  - `Processing → Shipped` (valid)
  - `Processing → Cancelled` (valid)
  - `Shipped → Delivered` (valid)
  - `Cancelled`, `Delivered`, `Shipped` → Cannot transition (terminal/semi-terminal states)

**Relationships**:
- Many orders belong to one customer (N:1 with Customer)

**Indexes**:
```sql
CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(status);
```

**State Diagram**:
```
    ┌──────────────┐
    │  Processing  │
    └──────┬───────┘
           │
      ┌────┴────┐
      │         │
      ▼         ▼
┌──────────┐  ┌──────────┐
│ Shipped  │  │Cancelled │
└────┬─────┘  └──────────┘
     │
     ▼
┌──────────┐
│Delivered │
└──────────┘
```

---

### 3. Conversation

**Purpose**: Represents a chat session between support agent and AI, optionally linked to a customer.

**Fields**:

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY | Unique conversation identifier (UUID v4) |
| customer_id | TEXT | NULLABLE, FOREIGN KEY → customers(id) | Reference to customer discussed (if any) |
| created_at | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | Conversation start time |
| updated_at | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | Last message time |

**Validation Rules**:
- `id`: Must be valid UUID v4 format
- `customer_id`: Must reference existing customer or be NULL (general inquiries)
- `created_at`: Automatically set on insert
- `updated_at`: Automatically updated on message insert

**Relationships**:
- One conversation optionally belongs to one customer (N:1 with Customer, nullable FK)
- One conversation has many messages (1:N with Message)

**Indexes**:
```sql
CREATE INDEX idx_conversations_customer_id ON conversations(customer_id);
CREATE INDEX idx_conversations_created_at ON conversations(created_at DESC);
```

---

### 4. Message

**Purpose**: Represents individual messages within a conversation, including AI tool invocations.

**Fields**:

| Field Name | Type | Constraints | Description |
|------------|------|-------------|-------------|
| id | TEXT | PRIMARY KEY | Unique message identifier (UUID v4) |
| conversation_id | TEXT | NOT NULL, FOREIGN KEY → conversations(id) | Parent conversation |
| role | TEXT | NOT NULL, CHECK (role IN (...)) | Message sender role |
| content | TEXT | NOT NULL | Message text content |
| tool_calls | JSON | NULLABLE | AI tool invocations (if role='assistant') |
| tool_results | JSON | NULLABLE | Tool execution results |
| created_at | TIMESTAMP | NOT NULL, DEFAULT CURRENT_TIMESTAMP | Message timestamp |

**Validation Rules**:
- `role`: Must be one of: `"user"`, `"assistant"`, `"system"`
- `content`: Non-empty for user/system messages; may be empty for assistant messages with tool_calls
- `tool_calls`: Valid JSON array of tool invocation objects (Claude API format)
- `tool_results`: Valid JSON array of tool result objects
- Message order: `created_at` determines chronological order within conversation

**Relationships**:
- Many messages belong to one conversation (N:1 with Conversation)

**Indexes**:
```sql
CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

**JSON Schema Examples**:

*Tool Calls (Assistant Message)*:
```json
{
  "tool_calls": [
    {
      "id": "toolu_01A09q90qw90lq917835lq9",
      "type": "function",
      "function": {
        "name": "get_user",
        "arguments": "{\"key\":\"email\",\"value\":\"john@example.com\"}"
      }
    }
  ]
}
```

*Tool Results*:
```json
{
  "tool_results": [
    {
      "tool_call_id": "toolu_01A09q90qw90lq917835lq9",
      "role": "tool",
      "content": "{\"id\":\"1213210\",\"name\":\"John Doe\",\"email\":\"john@example.com\",\"phone\":\"123-456-7891\",\"username\":\"johndoe\"}"
    }
  ]
}
```

---

## Database Schema (SQLite)

```sql
-- Enable foreign key constraints
PRAGMA foreign_keys = ON;

-- Enable WAL mode for better concurrency
PRAGMA journal_mode = WAL;
PRAGMA synchronous = NORMAL;

-- Customers table
CREATE TABLE customers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE,
    phone TEXT NOT NULL,
    username TEXT NOT NULL UNIQUE,
    CHECK (length(name) >= 1 AND length(name) <= 100),
    CHECK (email LIKE '%_@__%.__%'),
    CHECK (length(username) >= 3 AND length(username) <= 20)
);

-- Orders table
CREATE TABLE orders (
    id TEXT PRIMARY KEY,
    customer_id TEXT NOT NULL,
    product TEXT NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0 AND quantity < 1000),
    price REAL NOT NULL CHECK (price >= 0 AND price < 10000),
    status TEXT NOT NULL CHECK (status IN ('Processing', 'Shipped', 'Delivered', 'Cancelled')),
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE,
    CHECK (length(product) >= 1 AND length(product) <= 200)
);

-- Conversations table
CREATE TABLE conversations (
    id TEXT PRIMARY KEY,
    customer_id TEXT,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE SET NULL
);

-- Messages table
CREATE TABLE messages (
    id TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    tool_calls TEXT,  -- JSON stored as TEXT
    tool_results TEXT,  -- JSON stored as TEXT
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES conversations(id) ON DELETE CASCADE
);

-- Indexes for performance
CREATE INDEX idx_customers_email ON customers(email);
CREATE INDEX idx_customers_username ON customers(username);

CREATE INDEX idx_orders_customer_id ON orders(customer_id);
CREATE INDEX idx_orders_status ON orders(status);

CREATE INDEX idx_conversations_customer_id ON conversations(customer_id);
CREATE INDEX idx_conversations_created_at ON conversations(created_at DESC);

CREATE INDEX idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);
```

---

## SQLAlchemy ORM Models (Python)

The backend will use SQLAlchemy ORM models corresponding to the above schema. Key considerations:

**Relationships**:
```python
# models/customer.py
class Customer(Base):
    __tablename__ = "customers"
    orders = relationship("Order", back_populates="customer", cascade="all, delete-orphan")
    conversations = relationship("Conversation", back_populates="customer")

# models/order.py
class Order(Base):
    __tablename__ = "orders"
    customer = relationship("Customer", back_populates="orders")

# models/conversation.py
class Conversation(Base):
    __tablename__ = "conversations"
    customer = relationship("Customer", back_populates="conversations")
    messages = relationship("Message", back_populates="conversation", cascade="all, delete-orphan")

# models/message.py
class Message(Base):
    __tablename__ = "messages"
    conversation = relationship("Conversation", back_populates="messages")
```

**JSON Fields**:
SQLAlchemy will use `JSON` column type (stored as TEXT in SQLite, auto-serialized):
```python
tool_calls = Column(JSON, nullable=True)
tool_results = Column(JSON, nullable=True)
```

---

## Data Migration Mapping

**HuggingFace Datasets → SQLite**:

| Source | Destination | Transformation |
|--------|-------------|----------------|
| `dwb2023/blackbird-customers` → `train` split | `customers` table | Direct mapping, all fields preserved |
| `dwb2023/blackbird-orders` → `train` split | `orders` table | Direct mapping, all fields preserved |
| N/A (new) | `conversations` table | Empty initially, populated during chat usage |
| N/A (new) | `messages` table | Empty initially, populated during chat usage |

**Migration Validation**:
1. Record count verification: `SELECT COUNT(*) FROM customers` = 10
2. Record count verification: `SELECT COUNT(*) FROM orders` = 13
3. Referential integrity check: All `orders.customer_id` values exist in `customers.id`
4. Sample data verification: Spot-check 2-3 records for accuracy

---

## Pydantic Schemas (API Validation)

The API will use Pydantic models for request/response validation:

```python
# schemas/customer.py
class CustomerBase(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: EmailStr
    phone: str = Field(..., pattern=r'^\d{3}-\d{3}-\d{4}$')
    username: str = Field(..., min_length=3, max_length=20, pattern=r'^[a-zA-Z0-9_]+$')

class CustomerCreate(CustomerBase):
    id: str

class CustomerUpdate(BaseModel):
    email: EmailStr | None = None
    phone: str | None = Field(None, pattern=r'^\d{3}-\d{3}-\d{4}$')

class CustomerResponse(CustomerBase):
    id: str
    model_config = ConfigDict(from_attributes=True)
```

Similar schemas will be defined for Order, Conversation, and Message entities.

---

## Phase 1 Completion

Data model design complete. All entities, relationships, and validation rules defined. Ready to proceed to API contract generation.
